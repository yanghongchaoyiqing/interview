<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on Interview</title>
    <link>https://hadyang.github.io/interview/docs/basic/algo/</link>
    <description>Recent content in 算法 on Interview</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 21 Aug 2019 11:00:41 +0800</lastBuildDate>
    
	<atom:link href="https://hadyang.github.io/interview/docs/basic/algo/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>KMP</title>
      <link>https://hadyang.github.io/interview/docs/basic/algo/kmp/</link>
      <pubDate>Wed, 21 Aug 2019 11:00:41 +0800</pubDate>
      
      <guid>https://hadyang.github.io/interview/docs/basic/algo/kmp/</guid>
      <description>KMP算法 KMP算法解决的问题是字符匹配，这个算法把字符匹配的时间复杂度缩小到O(m+n),而空间复杂度也只有O(m),n是target的长度，m是pattern的长度。
  部分匹配表（Next数组）：表的作用是 让算法无需多次匹配S中的任何字符。能够实现线性时间搜索的关键是 在不错过任何潜在匹配的情况下，我们&amp;quot;预搜索&amp;quot;这个模式串本身并将其译成一个包含所有可能失配的位置对应可以绕过最多无效字符的列表。
  Next数组（前缀和前缀的比较）：t为模式串，j为下标
 Next[0] = -1 Next[j] = MAX{ k | 0 &amp;lt; k &amp;lt; j | &amp;quot; t0 t1 ... tk &amp;quot; = &amp;quot;t ( j-k ) t ( j-k+1 ) ... t( j-1 )&amp;quot; }    |i|	0|	1|	2|	3|	4|	5	|6| |&amp;ndash;| | t[i]|	A|	B|	C|	D|	A|	B|	D| |next[i]|	-1|	0	|0	|0	|0	|1	|2|</description>
    </item>
    
    <item>
      <title>哈希</title>
      <link>https://hadyang.github.io/interview/docs/basic/algo/hash/</link>
      <pubDate>Wed, 21 Aug 2019 11:00:41 +0800</pubDate>
      
      <guid>https://hadyang.github.io/interview/docs/basic/algo/hash/</guid>
      <description>Hash 哈希表（Hash Table，也叫散列表），是根据关键码值 (Key-Value) 而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。哈希表的实现主要需要解决两个问题，哈希函数和冲突解决。
哈希函数 哈希函数也叫散列函数，它对不同的输出值得到一个固定长度的消息摘要。理想的哈希函数对于不同的输入应该产生不同的结构，同时散列结果应当具有同一性（输出值尽量均匀）和雪崩效应（微小的输入值变化使得输出值发生巨大的变化）。
冲突解决  开放地址法：以发生冲突的哈希地址为输入，通过某种哈希冲突函数得到一个新的空闲的哈希地址的方法。有以下几种方式：  线性探查法：从发生冲突的地址开始，依次探查下一个地址，直到找到一个空闲单元。 平方探查法：设冲突地址为d0，则探查序列为：d0+1^2,d0-1^2,d0+2^2&amp;hellip;   拉链法：把所有的同义词用单链表链接起来。在这种方法下，哈希表每个单元中存放的不再是元素本身，而是相应同义词单链表的头指针。HashMap就是使用这种方法解决冲突的。  </description>
    </item>
    
    <item>
      <title>排序算法</title>
      <link>https://hadyang.github.io/interview/docs/basic/algo/sort/</link>
      <pubDate>Wed, 21 Aug 2019 11:00:41 +0800</pubDate>
      
      <guid>https://hadyang.github.io/interview/docs/basic/algo/sort/</guid>
      <description>排序算法 常见排序算法 稳定排序：  冒泡排序 — O(n²) 插入排序 — O(n²) 桶排序 — O(n); 需要 O(k) 额外空间 归并排序 — O(nlogn); 需要 O(n) 额外空间 二叉排序树排序 — O(n log n) 期望时间; O(n²)最坏时间; 需要 O(n) 额外空间 基数排序 — O(n·k); 需要 O(n) 额外空间  不稳定排序  选择排序 — O(n²) 希尔排序 — O(nlogn) 堆排序 — O(nlogn) 快速排序 — O(nlogn) 期望时间, O(n²) 最坏情况; 对于大的、乱数串行一般相信是最快的已知排序  交换排序 冒泡排序 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。冒泡排序总的平均时间复杂度为O(n^2)。冒泡排序是一种稳定排序算法。
 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。  void bubble_sort(int a[], int n) { int i, j, temp; for (j = 0; j &amp;lt; n - 1; j++) for (i = 0; i &amp;lt; n - 1 - j; i++) { if(a[i] &amp;gt; a[i + 1]) { temp = a[i]; a[i] = a[i + 1]; a[i + 1] = temp; } } } 快速排序 快速排序-百度百科 快速排序是一种 不稳定 的排序算法，平均时间复杂度为 O(nlogn)。快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。 步骤为：</description>
    </item>
    
    <item>
      <title>最小生成树算法</title>
      <link>https://hadyang.github.io/interview/docs/basic/algo/mst/</link>
      <pubDate>Wed, 21 Aug 2019 11:00:41 +0800</pubDate>
      
      <guid>https://hadyang.github.io/interview/docs/basic/algo/mst/</guid>
      <description>最小生成树算法   连通图：在无向图G中，若从顶点i到顶点j有路径，则称顶点i和顶点j是连通的。若图G中任意两个顶点都连通，则称G为连通图。
  生成树：一个连通图的生成树是该连通图的一个极小连通子图，它含有全部顶点，但只有构成一个数的(n-1)条边。
  最小生成树：对于一个带权连通无向图G中的不同生成树，各树的边上的 权值之和最小。构造最小生成树的准则有三条：
 必须只使用该图中的边来构造最小生成树。 必须使用且仅使用(n-1)条边来连接图中的n个顶点。 不能使用产生回路的边。    Prim算法 假设G=(V,E)是一个具有n个顶点的带权连通无向图，T(U,TE)是G的最小生成树，其中U是T的顶点集，TE是T的边集，则由G构造从起始顶点v出发的最小生成树T的步骤为：
  初始化U={v}，以v到其他顶点的所有边为候选边(U中所有点到其他顶点的边)。
  重复以下步骤(n-1)次，使得其他(n-1)个顶点被加入到U中。
  从候选边中挑选权值最小的边加入TE，设该边在V-U(这里是集合减)中的顶点是k，将k加入U中。
  考察当前V-U中的所有顶点j，修改候选边，若边(k,j)的权值小于原来和顶点j关联的候选边，则用(k,j)取代后者作为候选边。
    Kruskal算法 假设G=(V,E)是一个具有n个顶点的带权连通无向图，T(U,TE)是G的最小生成树，其中U是T的顶点集，TE是T的边集，则由G构造从起始顶点v出发的最小生成树T的步骤为：
  置U的初始值等于V(即包含G中的全部顶点)，TE的初始值为空
  将图G中的边按权值从小到大的顺序依次选取，若选取的边未使生成树T形成回路，则加入TE，否则放弃，知道TE中包含(n-1)条边为止。
  </description>
    </item>
    
    <item>
      <title>最短路径算法</title>
      <link>https://hadyang.github.io/interview/docs/basic/algo/path/</link>
      <pubDate>Wed, 21 Aug 2019 11:00:41 +0800</pubDate>
      
      <guid>https://hadyang.github.io/interview/docs/basic/algo/path/</guid>
      <description>最短路径算法 Dijkstra —— 贪心算法  从一个顶点到其余顶点的最短路径
 设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，第1组为已求出最短路径的顶点（用S表示，初始时S只有一个源点，以后每求得一条最短路径v,...k，就将k加到集合S中，直到全部顶点都加入S）。第2组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序把第2组的顶点加入S中。
步骤： 1. 初始时，S只包含源点，即`S={v}`，顶点v到自己的距离为0。U包含除v外的其他顶点，v到U中顶点i的距离为边上的权。 2. 从U中选取一个顶点u，顶点v到u的距离最小，然后把顶点u加入S中。 3. 以顶点u为新考虑的中间点，修改v到U中各个点的距离。 4. 重复以上步骤知道S包含所有顶点。 Floyd —— 动态规划 Floyd 算法是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权（但不可存在负权回路）的最短路径问题。该算法的时间复杂度为 $$O(N^{3})$$，空间复杂度为 $$O(N^{2})$$
设 $$D_{i,j,k}$$ 为从 $$i$$ 到 $$j$$ 的只以 $$(1..k)$$ 集合中的节点为中间节点的最短路径的长度。
$$ D_{i,j,k}=\begin{cases} D_{i,j,k-1} &amp;amp; 最短路径不经过 k\
D_{i,k,k-1}+D_{k,j,k-1} &amp;amp; 最短路径经过 k \end{cases} $$
因此， $$D_{i,j,k}=min(D_{i,k,k-1}+D_{k,j,k-1},D_{i,j,k-1})$$。伪代码描述如下：
// let dist be a |V| × |V| array of minimum distances initialized to ∞ (infinity) for each vertex v dist[v][v] ← 0 for each edge (u,v) dist[u][v] ← w(u,v) // the weight of the edge (u,v) for k from 1 to |V| for i from 1 to |V| for j from 1 to |V| if dist[i][j] &amp;gt; dist[i][k] + dist[k][j] dist[i][j] ← dist[i][k] + dist[k][j] end if </description>
    </item>
    
    <item>
      <title>查找算法</title>
      <link>https://hadyang.github.io/interview/docs/basic/algo/search/</link>
      <pubDate>Wed, 21 Aug 2019 11:00:41 +0800</pubDate>
      
      <guid>https://hadyang.github.io/interview/docs/basic/algo/search/</guid>
      <description>查找算法 ASL 由于查找算法的主要运算是关键字的比较，所以通常把查找过程中对关键字的平均比较次数（平均查找长度）作为衡量一个查找算法效率的标准。ASL= ∑(n,i=1) Pi*Ci，其中n为元素个数，Pi是查找第i个元素的概率，一般为Pi=1/n，Ci是找到第i个元素所需比较的次数。
顺序查找 原理是让关键字与队列中的数从最后一个开始逐个比较，直到找出与给定关键字相同的数为止，它的缺点是效率低下。时间复杂度o(n)。
折半查找 折半查找要求线性表是有序表。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。折半搜索每次把搜索区域减少一半，时间复杂度为O(log n)。
 可以借助二叉判定树求得折半查找的平均查找长度：log2(n+1)-1。 折半查找在失败时所需比较的关键字个数不超过判定树的深度，n个元素的判定树的深度和n个元素的完全二叉树的深度相同log2(n)+1。  public int binarySearchStandard(int[] num, int target){ int start = 0; int end = num.length - 1; while(start &amp;lt;= end){ //注意1 int mid = start + ((end - start) &amp;gt;&amp;gt; 1); if(num[mid] == target) return mid; else if(num[mid] &amp;gt; target){ end = mid - 1; //注意2 } else{ start = mid + 1; //注意3 } } return -1; }   如果是start &amp;lt; end，那么当target等于num[num.</description>
    </item>
    
    <item>
      <title>树</title>
      <link>https://hadyang.github.io/interview/docs/basic/algo/tree/</link>
      <pubDate>Wed, 21 Aug 2019 11:00:41 +0800</pubDate>
      
      <guid>https://hadyang.github.io/interview/docs/basic/algo/tree/</guid>
      <description>树 二叉树 L、D、R分别表示遍历左子树、访问根结点和遍历右子树
 先序遍历：DLR 中序遍历：LDR 后序遍历：LRD   仅有前序和后序遍历，不能确定一个二叉树，必须有中序遍历的结果
 二叉树的性质  性质1：在二叉树中第 i 层的结点数最多为2^(i-1)（i ≥ 1） 性质2：高度为k的二叉树其结点总数最多为2^k－1（ k ≥ 1） 性质3：对任意的非空二叉树 T ，如果叶结点的个数为 n0，而其度为 2 的结点数为 n2，则：n0 = n2 + 1  满二叉树 深度为k，且有2^k-1个节点称之为满二叉树；
 性质4：第i层上的节点数为2^(i-1)；  完全二叉树 深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树。
 性质5：对于具有n个结点的完全二叉树的高度为log2(n)+1  求完全二叉树的叶子结点个数：
二叉树的构造 //n 表示当前结点字符 Node* tree(vector&amp;lt;char&amp;gt; data, int n) { Node* node; if (n &amp;gt;= data.size()) return NULL; if (data[n] == &amp;#39;#&amp;#39;) return NULL; node = new Node; node-&amp;gt;data = data[n]; node-&amp;gt;left = tree(data, n + 1); node-&amp;gt;right = tree(data, n + 2); return node; } 堆 堆通常是一个可以被看做一棵树的数组对象。堆的实现通过构造二叉堆（binary heap），实为二叉树的一种；</description>
    </item>
    
    <item>
      <title>跳跃表</title>
      <link>https://hadyang.github.io/interview/docs/basic/algo/skip_list/</link>
      <pubDate>Wed, 21 Aug 2019 11:00:41 +0800</pubDate>
      
      <guid>https://hadyang.github.io/interview/docs/basic/algo/skip_list/</guid>
      <description>跳跃表 跳跃列表是一种数据结构。它允许快速查询一个有序连续元素的数据链表。跳跃列表的平均查找和插入时间复杂度都是 O(log n) ，优于普通队列的 O(n)。
快速查询是通过维护一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集。一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。跳过的元素的方法可以是 随机性选择 或 确定性选择，其中前者更为常见。
在查找目标元素时，从顶层列表、头元素起步。算法沿着每层链表搜索，直至找到一个大于或等于目标的元素，或者到达当前层列表末尾。如果该元素等于目标元素，则表明该元素已被找到；如果该元素大于目标元素或已到达链表末尾，则退回到当前层的上一个元素，然后转入下一层进行搜索。
跳跃列表不像平衡树等数据结构那样提供对最坏情况的性能保证：由于用来建造跳跃列表采用随机选取元素进入更高层的方法，在小概率情况下会生成一个不平衡的跳跃列表（最坏情况例如最底层仅有一个元素进入了更高层，此时跳跃列表的查找与普通列表一致）。但是在实际中它通常工作良好，随机化平衡方案也比平衡二叉查找树等数据结构中使用的确定性平衡方案容易实现。跳跃列表在并行计算中也很有用：插入可以在跳跃列表不同的部分并行地进行，而不用对数据结构进行全局的重新平衡。
跳跃表插入一个元素：
实现 因为跳跃列表中的元素可以在多个列表中，所以每个元素可以有多于一个指针。跳跃列表的插入和删除的实现与普通的链表操作类似，但高层元素必须在进行多个链表中进行插入或删除。
package io.github.hadyang.leetcode.algo; import lombok.Getter; import lombok.Setter; import java.util.Arrays; import java.util.Random; /** * @author haoyang.shi */ public class SkipList&amp;lt;K extends Comparable&amp;lt;K&amp;gt;, V&amp;gt; { @Getter @Setter static final class Node&amp;lt;K extends Comparable&amp;lt;K&amp;gt;, V&amp;gt; { private K key; private V value; private Node&amp;lt;K, V&amp;gt; up, down, pre, next; Node(K key, V value) { this.key = key; this.value = value; } @Override public String toString() { return &amp;quot;Node{&amp;quot; + &amp;quot;key=&amp;quot; + key + &amp;quot;, value=&amp;quot; + value + &amp;quot;, hashcode=&amp;quot; + hashCode() + &amp;quot;, up=&amp;quot; + (up == null ?</description>
    </item>
    
  </channel>
</rss>