<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="树"><meta property="og:title" content="树" />
<meta property="og:description" content="树 二叉树 L、D、R分别表示遍历左子树、访问根结点和遍历右子树
 先序遍历：DLR 中序遍历：LDR 后序遍历：LRD   仅有前序和后序遍历，不能确定一个二叉树，必须有中序遍历的结果
 二叉树的性质  性质1：在二叉树中第 i 层的结点数最多为2^(i-1)（i ≥ 1） 性质2：高度为k的二叉树其结点总数最多为2^k－1（ k ≥ 1） 性质3：对任意的非空二叉树 T ，如果叶结点的个数为 n0，而其度为 2 的结点数为 n2，则：n0 = n2 &#43; 1  满二叉树 深度为k，且有2^k-1个节点称之为满二叉树；
 性质4：第i层上的节点数为2^(i-1)；  完全二叉树 深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树。
 性质5：对于具有n个结点的完全二叉树的高度为log2(n)&#43;1  求完全二叉树的叶子结点个数：
二叉树的构造 //n 表示当前结点字符 Node* tree(vector&lt;char&gt; data, int n) { Node* node; if (n &gt;= data.size()) return NULL; if (data[n] == &#39;#&#39;) return NULL; node = new Node; node-&gt;data = data[n]; node-&gt;left = tree(data, n &#43; 1); node-&gt;right = tree(data, n &#43; 2); return node; } 堆 堆通常是一个可以被看做一棵树的数组对象。堆的实现通过构造二叉堆（binary heap），实为二叉树的一种；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hadyang.github.io/interview/docs/basic/algo/tree/" />
<meta property="article:published_time" content="2019-08-21T11:00:41+08:00" />
<meta property="article:modified_time" content="2019-08-21T11:00:41+08:00" />
<title>树 | Interview</title>
<link rel="icon" href="/interview/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/interview/book.min.68d45956421753cdf6bcfc865ede445c56afc5bcaaebfe02961f44fe77d8f45a.css" integrity="sha256-aNRZVkIXU832vPyGXt5EXFavxbyq6/4Clh9E/nfY9Fo=">


<script defer src="/interview/en.search.min.20e9a0fd2837302bf176773af2b5c6ff9fdbd4d86baeaf72d42e857a5793cf59.js" integrity="sha256-IOmg/Sg3MCvxdnc68rXG/5/b1Nhrrq9y1C6FeleTz1k="></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://hadyang.github.io/interview/"><span>Interview</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    <ul>
<li><a href="/interview/docs/basic/">计算机基础</a>
<ul>
<li><a href="/interview/docs/basic/algo/">算法</a>
<ul>
<li><a href="/interview/docs/basic/algo/tree/"class=active>树</a></li>
<li><a href="/interview/docs/basic/algo/hash/">Hash</a></li>
<li><a href="/interview/docs/basic/algo/mst/">最小生成树算法</a></li>
<li><a href="/interview/docs/basic/algo/path/">最短路径算法</a></li>
<li><a href="/interview/docs/basic/algo/kmp/">KMP算法</a></li>
<li><a href="/interview/docs/basic/algo/search/">查找算法</a></li>
<li><a href="/interview/docs/basic/algo/sort/">排序算法</a></li>
<li><a href="/interview/docs/basic/algo/skip_list/">跳跃表</a></li>
</ul>
</li>
<li><a href="/interview/docs/basic/os/">操作系统</a>
<ul>
<li><a href="/interview/docs/basic/os/arch/">计算机体系结构</a></li>
<li><a href="/interview/docs/basic/os/concurrency/">并发</a></li>
<li><a href="/interview/docs/basic/os/memory/">内存管理</a></li>
<li><a href="/interview/docs/basic/os/disk/">磁盘与文件</a></li>
<li><a href="/interview/docs/basic/os/linux/">Linux系统</a></li>
<li><a href="/interview/docs/basic/os/interrupt/">中断</a></li>
<li><a href="/interview/docs/basic/os/device/">设备管理</a></li>
<li><a href="/interview/docs/basic/os/io/">I/O</a></li>
<li><a href="/interview/docs/basic/os/questions/">面试题</a></li>
</ul>
</li>
<li><a href="/interview/docs/basic/net/">计算机网络</a>
<ul>
<li><a href="/interview/docs/basic/net/protocol/">底层网络协议</a></li>
<li><a href="/interview/docs/basic/net/tcp/">TCP</a></li>
<li><a href="/interview/docs/basic/net/ip/">IP</a></li>
<li><a href="/interview/docs/basic/net/http/">HTTP</a></li>
<li><a href="/interview/docs/basic/net/https/">HTTPS</a></li>
</ul>
</li>
<li><a href="/interview/docs/basic/database/">数据库</a>
<ul>
<li><a href="/interview/docs/basic/database/transaction/">事务</a></li>
<li><a href="/interview/docs/basic/database/index/">索引</a></li>
<li><a href="/interview/docs/basic/database/sql/">SQL</a></li>
<li><a href="/interview/docs/basic/database/join/">连接</a></li>
<li><a href="/interview/docs/basic/database/mysql/">MySQL</a></li>
<li><a href="/interview/docs/basic/database/concurrent/">并发控制</a></li>
<li><a href="/interview/docs/basic/database/innodb/">Innodb</a></li>
<li><a href="/interview/docs/basic/database/redis/">Redis</a></li>
</ul>
</li>
<li><a href="/interview/docs/basic/cryptology/">密码学</a></li>
</ul>
</li>
<li><a href="/interview/docs/java/">Java</a>
<ul>
<li><a href="/interview/docs/java/oop/">OOP</a></li>
<li><a href="/interview/docs/java/serilaser/">序列化</a></li>
<li><a href="/interview/docs/java/operator/">运算符</a></li>
<li><a href="/interview/docs/java/exception/">异常</a></li>
<li><a href="/interview/docs/java/generics/">泛型</a></li>
<li><a href="/interview/docs/java/object/">Object</a></li>
<li><a href="/interview/docs/java/string-builder/">StringBuilder</a></li>
<li><a href="/interview/docs/java/proxy/">代理</a></li>
<li><a href="/interview/docs/java/annotation/">注解</a></li>
<li><a href="/interview/docs/java/questions/">面试题</a></li>
<li><a href="/interview/docs/java/">集合</a>
<ul>
<li><a href="/interview/docs/java/collection/HashMap/">HashMap</a></li>
<li><a href="/interview/docs/java/collection/Concurrenthashmap/">Concurrenthashmap</a></li>
<li><a href="/interview/docs/java/collection/BlockQueue/">BlockQueue</a></li>
</ul>
</li>
<li><a href="/interview/docs/java/concurrent/">并发</a>
<ul>
<li><a href="/interview/docs/java/concurrent/thread/">线程</a></li>
<li><a href="/interview/docs/java/concurrent/volatile/">Volatile</a></li>
<li><a href="/interview/docs/java/concurrent/synchronized/">Synchronized</a></li>
<li><a href="/interview/docs/java/concurrent/AQS/">AQS</a></li>
<li><a href="/interview/docs/java/concurrent/count-down-latch/">CountDownLatch</a></li>
<li><a href="/interview/docs/java/concurrent/threadlocal/">Threadlocal</a></li>
<li><a href="/interview/docs/java/concurrent/interrupt/">线程中断</a></li>
</ul>
</li>
<li><a href="/interview/docs/java/jvm/">Java 虚拟机</a>
<ul>
<li><a href="/interview/docs/java/jvm/jvm-class-load-init/">类加载</a></li>
<li><a href="/interview/docs/java/jvm/jvm-class-loader/">类加载器</a></li>
<li><a href="/interview/docs/java/jvm/dispatcher/">Java分派机制</a></li>
<li><a href="/interview/docs/java/jvm/jvm-architecture/">虚拟机架构</a></li>
<li><a href="/interview/docs/java/jvm/memory-model/">内存模型</a></li>
<li><a href="/interview/docs/java/jvm/string-constant-pool/">String 常量池</a></li>
</ul>
</li>
<li><a href="/interview/docs/java/gc/">GC</a>
<ul>
<li><a href="/interview/docs/java/gc/jvm-gc/">Java 虚拟机垃圾收集</a></li>
<li><a href="/interview/docs/java/gc/jvm-object-lifecycle/">Java 虚拟机对象生命周期</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/interview/docs/fromwork/">框架</a>
<ul>
<li><a href="/interview/docs/fromwork/netty/">Netty</a></li>
<li><a href="/interview/docs/fromwork/mybatis/">Mybatis</a>
<ul>
<li><a href="/interview/docs/fromwork/mybatis/question/">面试题</a></li>
<li><a href="/interview/docs/fromwork/mybatis/cache/">缓存</a></li>
<li><a href="/interview/docs/fromwork/mybatis/proxy/">代理</a></li>
</ul>
</li>
<li><a href="/interview/docs/fromwork/spring/">Spring</a>
<ul>
<li><a href="/interview/docs/fromwork/spring/ioc/">IOC</a></li>
<li><a href="/interview/docs/fromwork/spring/design-partten/">设计模式</a></li>
<li><a href="/interview/docs/fromwork/spring/aop/">AOP</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/interview/docs/architecture/">系统架构</a>
<ul>
<li><a href="/interview/docs/architecture/base/">基本概念</a></li>
<li><a href="/interview/docs/architecture/concurrent/">高并发</a>
<ul>
<li><a href="/interview/docs/architecture/concurrent/flow-control/">流量控制</a></li>
</ul>
</li>
<li><a href="/interview/docs/architecture/design/">系统设计</a>
<ul>
<li><a href="/interview/docs/architecture/design/tinyURL/">短链接系统</a></li>
</ul>
</li>
<li><a href="/interview/docs/architecture/distributed/">分布式</a>
<ul>
<li><a href="/interview/docs/architecture/distributed/session/">分布式 Session</a></li>
<li><a href="/interview/docs/architecture/distributed/cache/">分布式缓存</a></li>
<li><a href="/interview/docs/architecture/distributed/lock/">分布式锁</a></li>
<li><a href="/interview/docs/architecture/distributed/transaction/">分布式事务</a></li>
<li><a href="/interview/docs/architecture/distributed/mq/">消息队列</a></li>
<li><a href="/interview/docs/architecture/distributed/zk/">Zookeeper</a></li>
<li><a href="/interview/docs/architecture/distributed/kafka/">Kafka</a></li>
<li><a href="/interview/docs/architecture/distributed/rpc/">远程调用</a></li>
<li><a href="/interview/docs/architecture/distributed/dubbo/">Dubbo</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/interview/docs/offer/">剑指offer</a>
<ul>
<li><a href="/interview/docs/offer/search-a-2d-matrix/">搜索二维矩阵</a></li>
<li><a href="/interview/docs/offer/replay-space/">替换空格</a></li>
<li><a href="/interview/docs/offer/print-link-from-tail/">从尾到头打印链表</a></li>
<li><a href="/interview/docs/offer/reConstructBinaryTree/">重建二叉树</a></li>
<li><a href="/interview/docs/offer/two-stack-fifo/">用两个栈实现一个队列</a></li>
<li><a href="/interview/docs/offer/find-minimum-in-rotated-sorted-array/">旋转数组的最小数字</a></li>
<li><a href="/interview/docs/offer/fibonacci/">斐波纳切数列</a></li>
<li><a href="/interview/docs/offer/number-of-one/">二进制中1的个数</a></li>
<li><a href="/interview/docs/offer/power/">数值的整数次方</a></li>
<li><a href="/interview/docs/offer/printn/">打印最大的 n 位数</a></li>
<li><a href="/interview/docs/offer/O1DeleteNode/">在O(1)的时间复杂度下删除节点</a></li>
<li><a href="/interview/docs/offer/reOrderArray/">调整数组顺序使奇数位于偶数前面</a></li>
<li><a href="/interview/docs/offer/FindKthToTail/">链表中倒数第k个结点</a></li>
<li><a href="/interview/docs/offer/revert-link/">反转链表</a></li>
<li><a href="/interview/docs/offer/merge-sort-link/">合并两个排序的链表</a></li>
<li><a href="/interview/docs/offer/HasSubtree/">树的子结构</a></li>
<li><a href="/interview/docs/offer/mirror-tree/">二叉树的镜像</a></li>
<li><a href="/interview/docs/offer/PrintMatrix/">顺时针打印矩阵</a></li>
<li><a href="/interview/docs/offer/MinStack/">包含min函数的栈</a></li>
<li><a href="/interview/docs/offer/IsPopOrder/">栈的压入、弹出序列</a></li>
<li><a href="/interview/docs/offer/PrintFromTopToBottom/">从上往下打印二叉树</a></li>
<li><a href="/interview/docs/offer/VerifySquenceOfBST/">二叉搜索树的后序遍历序列</a></li>
<li><a href="/interview/docs/offer/FindPath/">二叉树中和为某一值的路径</a></li>
<li><a href="/interview/docs/offer/CloneLink/">复杂链表的复制</a></li>
<li><a href="/interview/docs/offer/BST-Link-Convert/">二叉搜索树与双向链表</a></li>
<li><a href="/interview/docs/offer/Permutation/">字符串的排列</a></li>
<li><a href="/interview/docs/offer/MoreThanHalfNum/">数组中出现次数超过一半的数字</a></li>
<li><a href="/interview/docs/offer/GetLeastNumbers/">最小的K个数</a></li>
<li><a href="/interview/docs/offer/FindGreatestSumOfSubArray/">连续子数组的最大和</a></li>
<li><a href="/interview/docs/offer/NumberOfOneBetweenOneAndN/">从1到n整数中1出现的次数</a></li>
<li><a href="/interview/docs/offer/PrintMinNumber/">把数组排成最小的数</a></li>
<li><a href="/interview/docs/offer/GetUglyNumber/">丑数</a></li>
<li><a href="/interview/docs/offer/FirstNotRepeatingChar/">第一个只出现一次的字符</a></li>
<li><a href="/interview/docs/offer/InversePairs/">数组中的逆序对</a></li>
<li><a href="/interview/docs/offer/FindFirstCommonNode/">两个链表的第一个公共结点</a></li>
<li><a href="/interview/docs/offer/GetNumberOfK/">数字在排序数组中出现的次数</a></li>
<li><a href="/interview/docs/offer/TreeDepth/">二叉树的深度</a></li>
<li><a href="/interview/docs/offer/FindNumsAppearOnce/">数组中只出现一次的数字</a></li>
<li><a href="/interview/docs/offer/FindNumbersWithSum/">和为S的两个数字</a></li>
<li><a href="/interview/docs/offer/FindContinuousSequence/">和为S的连续正数序列</a></li>
<li><a href="/interview/docs/offer/ReverseSentence/">翻转单词顺序列</a></li>
<li><a href="/interview/docs/offer/LeftRotateString/">左旋转字符串</a></li>
<li><a href="/interview/docs/offer/SumOfNDice/">n个骰子的点数</a></li>
<li><a href="/interview/docs/offer/isContinuous/">扑克牌顺子</a></li>
<li><a href="/interview/docs/offer/LastRemaining/">圆圈中最后剩下的数</a></li>
<li><a href="/interview/docs/offer/sum/">求1+2+3+&hellip;+n</a></li>
<li><a href="/interview/docs/offer/Add/">不用加减乘除做加法</a></li>
<li><a href="/interview/docs/offer/Singleton/">单例</a></li>
<li><a href="/interview/docs/offer/Duplicate/">数组中重复的数字</a></li>
<li><a href="/interview/docs/offer/GetNext/">二叉树的下一个结点</a></li>
<li><a href="/interview/docs/offer/hasPath/">矩阵中的路径</a></li>
<li><a href="/interview/docs/offer/MovingCount/">机器人的运动范围</a></li>
<li><a href="/interview/docs/offer/CutRope/">剪绳子</a></li>
<li><a href="/interview/docs/offer/PatternMatch/">正则表达式匹配</a></li>
<li><a href="/interview/docs/offer/IsNumeric/">表示数值的字符串</a></li>
<li><a href="/interview/docs/offer/EntryNodeOfLoop/">链表中环的入口</a></li>
<li><a href="/interview/docs/offer/IsSymmetrical/">对称二叉树</a></li>
<li><a href="/interview/docs/offer/SerializeTree/">序列化二叉树</a></li>
<li><a href="/interview/docs/offer/StreamMid/">数据流中的中位数</a></li>
<li><a href="/interview/docs/offer/NOfNumberSerialize/">数字序列中的某一位的数字</a></li>
<li><a href="/interview/docs/offer/TranslateNumToStr/">把数字翻译成字符串</a></li>
<li><a href="/interview/docs/offer/MaxGift/">礼物的最大价值</a></li>
<li><a href="/interview/docs/offer/LongestNoRepeatSubString/">最长不含重复字符的子字符串</a></li>
<li><a href="/interview/docs/offer/CountOfSortedArray/">在排序数组中查找数字</a></li>
<li><a href="/interview/docs/offer/BSTKthNode/">二叉搜索树的第K大节点</a></li>
<li><a href="/interview/docs/offer/MaxInWindows/">滑动窗口的最大值</a></li>
<li><a href="/interview/docs/offer/MaxProfit/">股票的最大利润</a></li>
</ul>
</li>
<li><a href="/interview/docs/leetcode/">LeetCode</a>
<ul>
<li><a href="/interview/docs/leetcode/lengthOfLongestSubstring/">* 无重复字符的最长子串</a></li>
<li><a href="/interview/docs/leetcode/longestCommonPrefix/">最长公共前缀</a></li>
<li><a href="/interview/docs/leetcode/checkInclusion/">字符串的排列</a></li>
<li><a href="/interview/docs/leetcode/StringMultiply/">字符串相乘</a></li>
<li><a href="/interview/docs/leetcode/reverseWords/">翻转字符串里的单词</a></li>
<li><a href="/interview/docs/leetcode/simplifyPath/">* 简化路径</a></li>
<li><a href="/interview/docs/leetcode/restoreIpAddresses/">* 复原IP地址</a></li>
<li><a href="/interview/docs/leetcode/threeSum/">* 三数之和</a></li>
<li><a href="/interview/docs/leetcode/maxAreaOfIsland/">* 岛屿的最大面积</a></li>
<li><a href="/interview/docs/leetcode/searchRote/">* 搜索旋转排序数组</a></li>
<li><a href="/interview/docs/leetcode/findLengthOfLCIS/">最长连续递增序列</a></li>
<li><a href="/interview/docs/leetcode/findKthLargest/">数组中的第K个最大元素</a></li>
<li><a href="/interview/docs/leetcode/longestConsecutive/">最长连续序列</a></li>
<li><a href="/interview/docs/leetcode/findCircleNum/">* 朋友圈</a></li>
<li><a href="/interview/docs/leetcode/mergeRagen/">合并区间</a></li>
<li><a href="/interview/docs/leetcode/trap/">* 接雨水</a></li>
<li><a href="/interview/docs/leetcode/mergeTwoLists/">合并两个有序链表</a></li>
<li><a href="/interview/docs/leetcode/reverseList/">* 反转链表</a></li>
<li><a href="/interview/docs/leetcode/addTwoNumbers/">* 两数相加</a></li>
<li><a href="/interview/docs/leetcode/sortList/">* 排序链表</a></li>
<li><a href="/interview/docs/leetcode/detectCycle/">环形链表 II</a></li>
<li><a href="/interview/docs/leetcode/getIntersectionNode/">相交链表</a></li>
<li><a href="/interview/docs/leetcode/mergeKLists/">* 合并K个排序链表</a></li>
<li><a href="/interview/docs/leetcode/lowestCommonAncestor/">二叉树的最近公共祖先</a></li>
<li><a href="/interview/docs/leetcode/zigzagLevelOrder/">二叉树的锯齿形层次遍历</a></li>
<li><a href="/interview/docs/leetcode/maxProfit/">* 买卖股票的最佳时机</a></li>
<li><a href="/interview/docs/leetcode/maxProfit2/">* 买卖股票的最佳时机 II</a></li>
<li><a href="/interview/docs/leetcode/maxSubArray/">最大子序和</a></li>
<li><a href="/interview/docs/leetcode/MinStack/">* 最小栈</a></li>
<li><a href="/interview/docs/leetcode/LRUCache/">* LRU缓存机制</a></li>
<li><a href="/interview/docs/leetcode/AllOne/">全 O(1) 的数据结构</a></li>
<li><a href="/interview/docs/leetcode/mySqrt/">* x 的平方根</a></li>
<li><a href="/interview/docs/leetcode/validUtf8/">* UTF-8 编码验证</a></li>
<li><a href="/interview/docs/leetcode/salary/">* 第二高的薪水</a></li>
</ul>
</li>
</ul>





</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="/interview/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>
  <strong>树</strong>
</header>

      
<article class="markdown"><h1 id="树">树</h1>
<h2 id="二叉树">二叉树</h2>
<p>L、D、R分别表示遍历左子树、访问根结点和遍历右子树</p>
<ul>
<li>先序遍历：DLR</li>
<li>中序遍历：LDR</li>
<li>后序遍历：LRD</li>
</ul>
<blockquote>
<p>仅有前序和后序遍历，不能确定一个二叉树，必须有中序遍历的结果</p>
</blockquote>
<h3 id="二叉树的性质">二叉树的性质</h3>
<ul>
<li><code>性质1</code>：在二叉树中第 i 层的结点数最多为2^(i-1)（i ≥ 1）</li>
<li><code>性质2</code>：高度为k的二叉树其结点总数最多为2^k－1（ k ≥ 1）</li>
<li><code>性质3</code>：对任意的非空二叉树 T ，如果叶结点的个数为 n0，而其度为 2 的结点数为 n2，则：n0 = n2 + 1</li>
</ul>
<h3 id="满二叉树">满二叉树</h3>
<p>深度为k，且有<code>2^k-1</code>个节点称之为<code>满二叉树</code>；</p>
<ul>
<li><code>性质4</code>：第i层上的节点数为<code>2^(i-1)</code>；</li>
</ul>
<h3 id="完全二叉树">完全二叉树</h3>
<p>深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为<code>完全二叉树</code>。</p>
<ul>
<li><code>性质5</code>：对于具有n个结点的完全二叉树的高度为<code>log2(n)+1</code></li>
</ul>
<p>求完全二叉树的叶子结点个数：</p>
<p><img src="images/tree.jpg" alt=""></p>
<h3 id="二叉树的构造">二叉树的构造</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">//n 表示当前结点字符
</span><span style="color:#75715e"></span>Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">tree</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> data, <span style="color:#66d9ef">int</span> n) {

    Node<span style="color:#f92672">*</span> node;

    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> data.size())
        <span style="color:#66d9ef">return</span> NULL;
    <span style="color:#66d9ef">if</span> (data[n] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">#</span><span style="color:#e6db74">&#39;</span>)
        <span style="color:#66d9ef">return</span> NULL;

    node <span style="color:#f92672">=</span> new Node;
    node<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data <span style="color:#f92672">=</span> data[n];

    node<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>left <span style="color:#f92672">=</span> tree(data, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
    node<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>right <span style="color:#f92672">=</span> tree(data, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>);
    <span style="color:#66d9ef">return</span> node;
}
</code></pre></div><h2 id="堆">堆</h2>
<p>堆通常是一个可以被看做一棵树的数组对象。堆的实现通过构造二叉堆（binary heap），实为二叉树的一种；</p>
<ul>
<li>任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。</li>
<li><strong>堆总是一棵完全树</strong>。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。</li>
</ul>
<p>将根节点最大的堆叫做<code>最大堆</code>或大根堆，根节点最小的堆叫做<code>最小堆</code>或小根堆。常见的堆有二叉堆、斐波那契堆等。</p>
<p>通常堆是通过一维数组来实现的。在数组起始位置为1的情形中：</p>
<ul>
<li>父节点i的左子节点在位置<code>(2*i)</code>;</li>
<li>父节点i的右子节点在位置<code>(2*i+1)</code>;</li>
<li>子节点i的父节点在位置<code>(i/2)</code>;</li>
</ul>
<h2 id="霍夫曼树">霍夫曼树</h2>
<p>霍夫曼树又称最优二叉树，<strong>是一种带权路径长度最短的二叉树</strong>。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。<strong>树的路径长度是从树根到每一结点的路径长度之和</strong>，记为WPL=（W1<em>L1+W2</em>L2+W3<em>L3+&hellip;+Wn</em>Ln），N个权值Wi（i=1,2,&hellip;n）构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li（i=1,2,&hellip;n）。<strong>可以证明霍夫曼树的WPL是最小的</strong>。</p>
<h3 id="霍夫曼树构造">霍夫曼树构造</h3>
<ol>
<li>根据给定的n个权值<code>(W1,W2...Wn)</code>，使对应节点构成n个二叉树的森林<code>T=(T1,T2...Tn)</code>，其中每个二叉树<code>Ti(1 &lt;= i &lt;= n)</code>中都有一个带权值为Wi的根节点，其左、右子树均为空。</li>
<li>在森林T中选取两个节点权值最小的子树，分别作为左、右子树构造一个新的二叉树，且置新的二叉树的根节点的权值为其左右子树上根节点权值之和。</li>
<li>在森林T中，用新得到的二叉树替代选取的两个二叉树。</li>
<li>重复2和3，直到T只包含一个树为止。这个数就是霍夫曼树。</li>
</ol>
<blockquote>
<p>定理：对于具有n个叶子节点的霍夫曼树，共有<code>2n-1</code>个节点。这是由于霍夫曼树只有度为0和度为2的结点，根据二叉树的性质 <code>n0 = n2 + 1</code>，因此度为2的结点个数为<code>n-1</code>个，总共有<code>2n-1</code>个节点。</p>
</blockquote>
<h3 id="霍夫曼编码">霍夫曼编码</h3>
<p>对于一个霍夫曼树，所有左链接取'0&rsquo;、右链接取'1&rsquo;。从树根至树叶依序记录所有字母的编码。</p>
<h3 id="带权路径">带权路径</h3>
<ul>
<li><code>结点的权</code>：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。</li>
<li><code>结点的带权路径</code>：从根结点到该结点之间的路径长度与该结点的权的乘积。</li>
<li><code>树的带权路径</code>：所有叶子结点的带权路径长度之和，记为<code>WPL</code>。</li>
</ul>
<h2 id="二叉排序树">二叉排序树</h2>
<p>二叉查找树，也称二叉搜索树、有序二叉树，排序二叉树，是指一棵空树或者具有下列性质的二叉树：</p>
<ul>
<li>任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的节点。</li>
</ul>
<p>二分查找的时间复杂度是O(log(n))，最坏情况下的时间复杂度是O(n)（相当于顺序查找）</p>
<h2 id="平衡二叉树">平衡二叉树</h2>
<p>平衡树是计算机科学中的一类改进的二叉查找树。一般的二叉查找树的查询复杂度是跟目标结点到树根的距离（即深度）有关，因此当结点的深度普遍较大时，查询的均摊复杂度会上升，为了更高效的查询，平衡树应运而生了。<strong>平衡指所有叶子的深度趋于平衡，更广义的是指在树上所有可能查找的均摊复杂度偏低。</strong></p>
<h3 id="avl树httpszhwikipediaorgwikiavle6a091"><a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91">AVL树</a></h3>
<p>AVL树是最先发明的 <strong>自平衡二叉查找树</strong>。在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。</p>
<ul>
<li>它的左子树和右子树都是平衡二叉树。</li>
<li>左子树和右子树的深度之差的绝对值不超过1。</li>
</ul>
<p>增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p>
<ul>
<li>右旋：左结点转到根节点位置。</li>
<li>左旋：右节点转到根节点位置。</li>
</ul>
<blockquote>
<p>高度为<code>k</code>的AVL树，节点数N最多<code>2^k -1</code>，即满二叉树；</p>
</blockquote>
<h3 id="红黑树">红黑树</h3>
<p>红黑树是一种自平衡二叉查找树，每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p>
<ul>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ul>
<blockquote>
<p>如果一条路径上的顶点除了起点和终点可以相同外，其它顶点均不相同，则称此路径为一条简单路径；起点和终点相同的简单路径称为回路（或环）。</p>
</blockquote>
<p><img src="images/red_black_tree.png" alt=""></p>
<blockquote>
<p>红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。</p>
</blockquote>
<p>这些约束确保了红黑树的关键特性：<strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</strong>。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限 <strong>允许红黑树在最坏情况下都是高效的</strong>，而不同于普通的二叉查找树。</p>
<p>在很多树数据结构的表示中，一个节点有可能只有一个子节点，而叶子节点包含数据。用这种范例表示红黑树是可能的，但是这会改变一些性质并使算法复杂。为此，本文中我们使用&quot;nil叶子&quot;或&quot;空（null）叶子&rdquo;，如上图所示，它不包含数据而只充当树在此结束的指示。<strong>这些节点在绘图中经常被省略，导致了这些树好像同上述原则相矛盾，而实际上不是这样</strong>。与此有关的结论是所有节点都有两个子节点，尽管其中的一个或两个可能是空叶子。</p>
<p>因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。<strong>恢复红黑树的性质需要少量（O(log n)）的颜色变更（实际是非常快速的）和不超过三次树旋转（对于插入操作是两次）</strong>。虽然插入和删除很复杂，但操作时间仍可以保持为O(log n)次。</p>
<h2 id="b-树">B-树</h2>
<p>是一种多路搜索树（并不是二叉的）：</p>
<ol>
<li>所有叶子结点位于同一层，并且 <strong>不带信息</strong>。</li>
<li>树中每个节点最多有m个子树(即至多含有m-1个关键字)。</li>
<li>若根节点不是终端节点，则根节点子树[2,m].</li>
<li>除根节点外其他非叶子节点至少有[m/2]个子树(即至少含有[m/2]-1个关键字)。</li>
<li>每个非叶子节点的结构为：</li>
</ol>
<p>| n | p0 | k1 | p1 | k2 | p2 | &hellip; | kn | pn |</p>
<blockquote>
<p>n为该节点中的关键字个数，除根节点外，其他所有非叶子节点的关键字个数n：[m/2]-1 &lt;= n &lt;= m-1;</p>
</blockquote>
<blockquote>
<p>ki(i &lt;= i &lt;=n)为该节点的关键字且满足ki &lt; ki+1</p>
</blockquote>
<blockquote>
<p>pi(0 &lt;= i &lt;=n)为该节点的孩子节点指针pi(0 &lt;= i &lt;=n-1)所指节点上的关键字大于等于ki且小于ki+1，pn所指节点上的关键字大于kn.</p>
</blockquote>
<blockquote>
<p>B-树的阶：所有节点的孩子节点数的最大值</p>
</blockquote>
<p><img src="images/b-.png" alt=""></p>
<h3 id="b-树的查找">B-树的查找</h3>
<p>在B-树中的查找给定关键字的方法 <strong>类似于二叉排序树上的查找，不同的是在每个节点上确定向下查找的路径不一定是二路的，而是n+1路的</strong>。因为节点内的关键字序列key[1..n]有序，故既可以使用顺序查找，也可以使用二分查找。在一棵B-树上查找关键字为k的方法为：将k与根节点中的key[i]进行比较：</p>
<ol>
<li>若k=key[i]，则查找成功；</li>
<li>若k&lt;key[1]，则沿指针ptr[0]所指的子树继续查找；</li>
<li>若key[i]&lt;k&lt;key[i+1]，则沿着指针ptr[i]所指的子树继续查找；</li>
<li>若k&gt;key[n]，则沿着指针ptr[n]所指的子树继续查找。</li>
</ol>
<h3 id="b-树的插入">B-树的插入</h3>
<p>将关键字k插入到B-树的过程分两步完成：</p>
<ol>
<li>
<p>利用B-树的查找算法查找出该关键字的插入节点(注意B-树的插入节点一定属于最低非叶子节点层)。</p>
</li>
<li>
<p>判断该节点是否还有空位，即判断该节点是否满足n &lt; m-1，若满足：直接把关键字k插入到该节点合适位置上；若不满足：分裂节点，取一新节点，把原节点上的关键字和k按升序排列后，从中间位置(m/2)处把关键字(不包括中间位置的关键字)分成两部分，左部分所含关键字放在旧节点中，右部分关键字放在新节点中，中间位置的关键字连同新节点的存储位置插入到双亲节点。如果双亲节点的关键字个数也超出max则再分裂。</p>
</li>
</ol>
<h3 id="b-树的删除">B-树的删除</h3>
<p>首先查找B树中需删除的元素，如果该元素在B树中存在，则将该元素在其结点中进行删除；如果删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素到父节点中，然后是移动之后的情况；如果没有，直接删除后，然后是移动之后的情况。</p>
<p>删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于Min(m/2)-1，则需要看其某相邻兄弟结点是否丰满，如果丰满，则向父节点借一个元素来满足条件；如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于Min(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，</p>
<h2 id="b树">B+树</h2>
<p>是一种自平衡二叉树，通常用于数据库和操作系统的文件系统中。B+树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+树元素自底向上插入，这与二叉树恰好相反。<strong>B+树不需要象其他自平衡二叉查找树那样经常的重新平衡。</strong></p>
<p><img src="images/b+.png" alt=""></p>
<p>B+树是B-树的变体，也是一种多路搜索树：</p>
<ol>
<li>每个分支节点最多m个子树</li>
<li>根节点没有子树或至少两个子树</li>
<li>除根节点外，其他每个分支节点至少[m/2]个子树</li>
<li>有n个子树的节点有n个关键字</li>
<li>所有叶子节点包含全部关键字及指向相应记录的指针，而且叶子节点按关键字大小顺序链接(可以把每个叶子及诶单看成一个基本索引块，它的指针不再指向另一级索引块，而是直接指向数据文件中的记录)</li>
<li>所有分支节点中仅仅包含它的哥哥子节点(即下级索引块)中最大关键字及指向子节点的指针。</li>
</ol>
<p>m阶的B+树和B-树的主要差异如下：</p>
<ul>
<li>在B+树中，具有n个关键字的节点含有n个子树，即每个关键字对应一个子树，而在B-树中，具有n个关键字的节点含有(n+1)个子树。</li>
<li>在B+树中，每个节点(除根节点外)中的关键字个数n的取值范围是[m/2] &lt;= n &lt;= m，根节点n的取值范围2 &lt;=n &lt;=m；而在B-树中，除根节点外，其他所有非叶子节点的关键字个数：[m/2]-1 &lt;= n &lt;= m-1，根节点关键字个数为1 &lt;= n &lt;= m-1</li>
<li><strong>B+树中所有叶子节点包含了全部关键字，即其他非叶子节点中的关键字包含在叶子节点中，而在B-树中，关键字是不重复的。</strong></li>
<li><strong>B+树中所有非叶子节点仅起到索引的作用</strong>，即节点中每个索引项值含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。而在B-树中，每个关键字对应一个记录的存储地址。</li>
<li>通常B+树上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，所有叶子节点链接成一个不定长的线性表。</li>
</ul>
<h3 id="b树的查找">B+树的查找</h3>
<p>在B+树中可以采用两种查找方式：</p>
<ul>
<li>直接从最小关键字开始顺序查找。</li>
<li>从B+树的根节点开始随机查找。这种查找方式与B-树的查找方式类似，只是在分支节点上的关键字与查找值相等时，查找并不会结束，要继续查到叶子节点为止，此时若查找成功，则按所给指针取出对应元素。</li>
</ul>
<p>在B+树中，不管查找是否成功，<strong>每次查找都是经历一条树从根节点到叶子节点的路径</strong>。</p>
<h3 id="b树的插入">B+树的插入</h3>
<ol>
<li>首先，查找要插入其中的节点的位置。接着把值插入这个节点中。</li>
<li>如果没有节点处于违规状态则处理结束。</li>
<li>如果某个节点有过多元素，则把它分裂为两个节点，每个都有最小数目的元素。在树上递归向上继续这个处理直到到达根节点，如果根节点被分裂，则创建一个新根节点。为了使它工作，元素的最小和最大数目典型的必须选择为使最小数不小于最大数的一半。</li>
</ol>
<h3 id="b树的删除">B+树的删除</h3>
<ol>
<li>首先，查找要删除的值。接着从包含它的节点中删除这个值。</li>
<li>如果没有节点处于违规状态则处理结束。</li>
<li>如果节点处于违规状态则有两种可能情况：
- 它的兄弟节点，就是同一个父节点的子节点，可以把一个或多个它的子节点转移到当前节点，而把它返回为合法状态。如果是这样，在更改父节点和两个兄弟节点的分离值之后处理结束。
- 它的兄弟节点由于处在低边界上而没有额外的子节点。在这种情况下把两个兄弟节点合并到一个单一的节点中，而且我们递归到父节点上，因为它被删除了一个子节点。持续这个处理直到当前节点是合法状态或者到达根节点，在其上根节点的子节点被合并而且合并后的节点成为新的根节点。</li>
</ol>
<blockquote>
<p>B-树和B+树 主要用于外部查找，即数据在外存中。</p>
</blockquote>
<h3 id="b树的优势所在">B+树的优势所在</h3>
<p>为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</p>
<ol>
<li>B+树的磁盘读写代价更低</li>
</ol>
<pre><code>我们都知道磁盘时可以块存储的，也就是同一个磁道上同一盘块中的所有数据都可以一次全部读取。而B+树的内部结点并没有指向关键字具体信息的指针(比如文件内容的具体地址 ） 。因此其内部结点相对B-树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。这样，一次性读入内存中的需要查找的关键字也就越多。**相对来说IO读写次数也就降低了**。

举个例子，假设磁盘中的一个盘块容纳`16bytes`，而一个关键字`2bytes`，一个关键字具体信息指针`2bytes`。一棵9阶B-树(一个结点最多8个关键字)的内部结点需要2个盘块。而B+树内部结点只需要1个盘块。**当需要把内部结点读入内存中的时候，B-树就比B+数多一次盘块查找时间（在磁盘中就是盘片旋转的时间）**。
</code></pre>
<ol start="2">
<li>B+树的查询效率更加稳定。</li>
</ol>
<pre><code>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。**所有关键字查询的路径长度相同，导致每一个数据的查询效率相当**。
</code></pre>
<h2 id="trie树">Trie树</h2>
<p><code>Trie树</code>，又称前缀树，<code>字典树</code>， 是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。<strong>一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串</strong>。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p><strong>Trie树查询和插入时间复杂度都是 O(n)，是一种以空间换时间的方法。当节点树较多的时候，Trie 树占用的内存会很大</strong>。</p>
<p>Trie树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p>
</article>

      <div class="book-footer justify-between">
  

  

  
  <div>
    <a class="flex align-center" href="https://github.com/hadyang/interview/edit/master/content/docs/basic/algo/tree/index.md" target="_blank">
      <img src="/interview/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>
  

</div>

      
    </div>

    
  

  <aside class="book-toc levels-3 fixed">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#二叉树">二叉树</a>
      <ul>
        <li><a href="#二叉树的性质">二叉树的性质</a></li>
        <li><a href="#满二叉树">满二叉树</a></li>
        <li><a href="#完全二叉树">完全二叉树</a></li>
        <li><a href="#二叉树的构造">二叉树的构造</a></li>
      </ul>
    </li>
    <li><a href="#堆">堆</a></li>
    <li><a href="#霍夫曼树">霍夫曼树</a>
      <ul>
        <li><a href="#霍夫曼树构造">霍夫曼树构造</a></li>
        <li><a href="#霍夫曼编码">霍夫曼编码</a></li>
        <li><a href="#带权路径">带权路径</a></li>
      </ul>
    </li>
    <li><a href="#二叉排序树">二叉排序树</a></li>
    <li><a href="#平衡二叉树">平衡二叉树</a>
      <ul>
        <li><a href="#avl树httpszhwikipediaorgwikiavle6a091">AVL树</a></li>
        <li><a href="#红黑树">红黑树</a></li>
      </ul>
    </li>
    <li><a href="#b-树">B-树</a>
      <ul>
        <li><a href="#b-树的查找">B-树的查找</a></li>
        <li><a href="#b-树的插入">B-树的插入</a></li>
        <li><a href="#b-树的删除">B-树的删除</a></li>
      </ul>
    </li>
    <li><a href="#b树">B+树</a>
      <ul>
        <li><a href="#b树的查找">B+树的查找</a></li>
        <li><a href="#b树的插入">B+树的插入</a></li>
        <li><a href="#b树的删除">B+树的删除</a></li>
        <li><a href="#b树的优势所在">B+树的优势所在</a></li>
      </ul>
    </li>
    <li><a href="#trie树">Trie树</a></li>
  </ul>
</nav>
  </aside>



  </main>

  
</body>

</html>
